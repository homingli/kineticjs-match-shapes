// Generated by CoffeeScript 1.6.3
(function() {
  (function() {
    var box, boxFrame, box_h, box_w, circle, circleFrame, findBounds, isposmatch, makeframe, messageLayer, msg, shapeLayer, shapes, stage, test_and_complete, tolerance, triangle, triangleFrame, winH, winW, writeMessage;
    tolerance = 50;
    winW = 630;
    winH = 460;
    if (document.body && document.body.offsetWidth) {
      winW = document.body.offsetWidth;
      winH = document.body.offsetHeight;
    }
    if (document.compatMode === "CSS1Compat" && document.documentElement && document.documentElement.offsetWidth) {
      winW = document.documentElement.offsetWidth;
      winH = document.documentElement.offsetHeight;
    }
    if (window.innerWidth && window.innerHeight) {
      winW = window.innerWidth;
      winH = window.innerHeight;
    }
    stage = new Kinetic.Stage({
      container: "container",
      width: winW,
      height: winH
    });
    /*
    start= (new Date()).getTime()
    setInterval (->
      writeMessage(timerLayer,'Timer: '+(Math.round(((new Date()).getTime()-start)/100)/10)+'s')
    ), 100
    */

    shapes = {
      'circle': {
        'color': 'red',
        'x': Math.random() * stage.getWidth(),
        'y': Math.random() * stage.getHeight()
      },
      'box': {
        'color': "#00D2FF",
        'x': Math.random() * stage.getWidth(),
        'y': Math.random() * stage.getHeight()
      },
      'triangle': {
        'color': "yellow",
        'x': Math.random() * stage.getWidth(),
        'y': Math.random() * stage.getHeight()
      }
    };
    writeMessage = function(messageLayer, message, c) {
      if (typeof c === 'undefined') {
        c = "black";
      }
      /*
      context = messageLayer.getContext()
      messageLayer.clear()
      context.font = "18pt Calibri"
      context.fillStyle = c
      context.fillText message, 10, 25
      */

      msg.setFill(c);
      msg.setStroke('black');
      msg.setStrokeWidth(1);
      msg.setText(message);
      return messageLayer.draw();
    };
    makeframe = function(shape) {
      var frame, h, new_x, new_y, w;
      frame = shape.clone();
      frame.setFill("#000");
      frame.setDraggable(false);
      new_x = Math.random() * stage.getWidth();
      new_y = Math.random() * stage.getHeight();
      if (frame.toObject().className === "Rect") {
        w = frame.getWidth();
        h = frame.getHeight();
      } else {
        w = h = frame.getRadius();
      }
      if (new_x + w > stage.getWidth()) {
        new_x = new_x - w;
      }
      if (new_y + h > stage.getHeight()) {
        new_y = new_y - h;
      }
      if (new_x - w < 0) {
        new_x = new_x + w;
      }
      if (new_y - h < 0) {
        new_y = new_y + h;
      }
      /*
      # old style = recreate shape
      debug_counter = 0
      flag = true
      while flag
        new_x = Math.random() * stage.getWidth()
        new_y = Math.random() * stage.getHeight()
        if frame.toObject().className is "Rect"
          w = frame.getWidth()
          h = frame.getHeight()
        else
          w = h = frame.getRadius()
      
        # check upperbound
        over_upper = ((new_x + w > stage.getWidth()) or (new_y + h > stage.getHeight()))
      
        # check lowerbound
        under_lower = ((new_x - w < 0) or (new_y - h < 0))
        flag = (over_upper or under_lower)
        console.log ++debug_counter
      # endwhile
      */

      console.log(frame.toObject().className, new_x, new_y);
      frame.setPosition(new_x, new_y);
      return frame;
    };
    isposmatch = function(shape, frame) {
      var f_x, f_y, s_x, s_y;
      s_x = Math.round(shape.getX());
      s_y = Math.round(shape.getY());
      f_x = Math.round(frame.getX());
      f_y = Math.round(frame.getY());
      return (Math.abs(s_x - f_x) <= tolerance) && (Math.abs(s_y - f_y) <= tolerance);
    };
    test_and_complete = function(shape, frame, msg, cb) {
      var config;
      if (isposmatch(shape, frame)) {
        new Audio("applause.mp3").play();
        writeMessage(messageLayer, msg, shape.getFill());
        shape.setPosition(frame.getAbsolutePosition().x, frame.getAbsolutePosition().y);
        shapeLayer.draw();
        config = {};
        config.scale = {
          x: 0,
          y: 0
        };
        config.opacity = 0;
        config.duration = 0.5;
        config.easing = "ease-out";
        frame.hide();
        if (shape.toObject().className === "Rect") {
          config.x = shape.getAbsolutePosition().x + (shape.getWidth() / 2);
          config.y = shape.getAbsolutePosition().y + (shape.getHeight() / 2);
        }
        shape.transitionTo(config);
        setTimeout((function() {
          if (!circleFrame.isVisible() && !boxFrame.isVisible() && !triangleFrame.isVisible()) {
            new Audio("tada.mp3").play();
            writeMessage(messageLayer, 'Congrats! All Done!');
            circleFrame.setFill(shapes.circle.color);
            circleFrame.show();
            boxFrame.setFill(shapes.box.color);
            boxFrame.show();
            triangleFrame.setFill(shapes.triangle.color);
            triangleFrame.show();
            stage.draw();
            return setInterval((function() {
              if (messageLayer.isVisible()) {
                return messageLayer.hide();
              } else {
                return messageLayer.show();
              }
            }), 500);
          }
        }), 1000);
        if (cb) {
          return cb();
        }
      }
    };
    shapeLayer = new Kinetic.Layer();
    messageLayer = new Kinetic.Layer();
    circle = new Kinetic.Circle({
      x: shapes.circle.x,
      y: shapes.circle.y,
      radius: Math.max(100, Math.random() * stage.getWidth() / 8),
      fill: shapes.circle.color,
      stroke: "black",
      strokeWidth: 2,
      draggable: true
    });
    box_w = box_h = Math.max(150, Math.random() * stage.getWidth() / 6);
    box = new Kinetic.Rect({
      x: shapes.box.x,
      y: shapes.box.y,
      width: box_w,
      height: box_h,
      fill: shapes.box.color,
      rotationDeg: Math.random() * 180,
      stroke: "black",
      strokeWidth: 2,
      draggable: true
    });
    triangle = new Kinetic.RegularPolygon({
      x: shapes.triangle.x,
      y: shapes.triangle.y,
      sides: 3,
      radius: Math.max(120, Math.random() * stage.getWidth() / 8),
      stroke: "black",
      fill: shapes.triangle.color,
      rotationDeg: Math.random() * 120,
      strokeWidth: 2,
      draggable: true
    });
    boxFrame = makeframe(box);
    circleFrame = makeframe(circle);
    triangleFrame = makeframe(triangle);
    msg = new Kinetic.Text({
      x: 10,
      y: stage.getHeight() / 2,
      text: '',
      align: 'center',
      fontSize: 64,
      fontFamily: 'Calibri',
      textFill: 'green'
    });
    circle.on("dragstart", function() {
      this.moveToTop();
      return writeMessage(messageLayer, "CIRCLE", this.getFill());
      /*
      this.setAttrs {
        shadow: { offset: { x: 5, y: 5 } }
        scale: { x: 1.1, y: 1.1 }
      }
      */

    });
    circle.on("touchend dragend", function() {
      /*
      this.setAttrs {
        shadow: { offset: { x: 0, y: 0 } }
        scale: { x: 1, y: 1 }
      }
      shapeLayer.draw()
      */

      return test_and_complete(this, circleFrame, "CIRCLE");
    });
    box.on("dragstart", function() {
      this.moveToTop();
      return writeMessage(messageLayer, "SQUARE", this.getFill());
    });
    box.on("touchend dragend", function() {
      return test_and_complete(this, boxFrame, "SQUARE");
    });
    triangle.on("dragstart", function() {
      this.moveToTop();
      return writeMessage(messageLayer, "TRIANGLE", this.getFill());
    });
    triangle.on("touchend dragend", function() {
      return test_and_complete(this, triangleFrame, "TRIANGLE");
    });
    findBounds = function(shape) {
      var s_h, s_r, s_w, x_lower, x_upper, y_lower, y_upper;
      if (shape.toObject().className === "Rect") {
        s_w = shape.getWidth();
        s_h = shape.getHeight();
        x_upper = shape.getX() + s_w / 2;
        x_lower = shape.getX() - s_w / 2;
        y_upper = shape.getY() + s_h / 2;
        y_lower = shape.getY() - s_h / 2;
      } else {
        s_r = shape.getRadius();
        x_upper = shape.getX() + s_r;
        x_lower = shape.getX() - s_r;
        y_upper = shape.getY() + s_r;
        y_lower = shape.getY() - s_r;
      }
      return {
        x: [x_lower, x_upper],
        y: [y_lower, y_upper]
      };
    };
    circleFrame.bounds = findBounds(circleFrame);
    triangleFrame.bounds = findBounds(triangleFrame);
    boxFrame.bounds = findBounds(boxFrame);
    messageLayer.add(msg);
    shapeLayer.add(circleFrame);
    shapeLayer.add(triangleFrame);
    shapeLayer.add(boxFrame);
    shapeLayer.add(circle);
    shapeLayer.add(triangle);
    shapeLayer.add(box);
    stage.clear();
    stage.add(shapeLayer);
    return stage.add(messageLayer);
  })();

}).call(this);
